#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language french
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Rapport de projet informatique
\end_layout

\begin_layout Title
INSAtram
\end_layout

\begin_layout Author
Alix ANNERAUD - Myriem ABID - Hugo LASCOUTS
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction.
\end_layout

\begin_layout Subsection
Présentation
\end_layout

\begin_layout Standard
Le nom du projet est 
\begin_inset Quotes fld
\end_inset

INSAtram
\begin_inset Quotes frd
\end_inset

.
 Cela fait référence au mot 
\begin_inset Quotes fld
\end_inset

Tram
\begin_inset Quotes frd
\end_inset

 désignant un moyen de transport urbain.
 Ainsi, le jeu consiste en la construction et gestion d’un réseau de transport
 ferroviaire.
 Le concept n'est pas original.
 En effet, il à été inspiré du jeu 
\begin_inset Quotes fld
\end_inset

Mini Metro
\begin_inset Quotes frd
\end_inset

 de l'éditeur <>.
\end_layout

\begin_layout Standard
L’objectif du joueur est que l’acheminement des passagers vers leurs destination
s soit optimal.
 Plusieurs stations qu’il faudra relier entre elles apparaissent au fil
 de la partie.
 Les passagers apparaîtront à côté de leur station de départ et emprunteront
 la ou les lignes qui desservent leur station afin d’atteindre leur destination.
 Certaines cartes pourront contenir des fleuves dès le début de la partie.
 L’identité graphique du jeu s’apparentera aux cartes de réseaux disponibles
 dans les transports en commun.
\end_layout

\begin_layout Standard
Les lignes reliant les stations seront de différentes couleurs, elles sont
 semblables à celles que l'on voit sur les vraies cartes de transport en
 commun.
 Lorsqu’une ligne est créée, un véhicule apparaîtra sur cette dernière et
 y fera des allers-retours.
 Il est possible de librement supprimer ou réorganiser les lignes à tout
 moment de la partie.
\end_layout

\begin_layout Standard
Les réseaux deviennent de plus en plus complexes au fur et à mesure de la
 partie, le joueur pourra recevoir des objets (items cités dans les fonctionnali
tés) à différents moments de la partie afin de l’aider dans la gestion des
 réseaux.
 
\end_layout

\begin_layout Standard
Enfin, le joueur perd lorsque son réseau n’est plus efficace.
 C’est-à-dire lorsqu’une station accueille un nombre de passagers supérieur
 à sa capacité pendant un certain temps.
\end_layout

\begin_layout Subsection
Cahier des charges initial
\end_layout

\begin_layout Standard
Voici le cahier des charges initial.
 Les 
\bar under
parties soulignées
\bar default
 sont les fonctionnalités optionnelles et seront réalisées si l’avancement
 du projet le permet.
\end_layout

\begin_layout Itemize

\series bold
Interface graphique : 
\series default
L’interface graphique comportera les éléments suivants :
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Menu de démarrage :
\series default
 Il permettra de commencer une partie, de sélectionner un niveau de difficulté,
 de choisir une carte, de paramétrer l'échelle de l'interface graphique,
 de charger une partie à partir d’un fichier et également de changer le
 niveau du son.
 Il comprendra également un onglet “à propos” comprenant des crédits ainsi
 que des explications sur le jeu etc.
\end_layout

\begin_layout Itemize

\series bold
Terrain de jeu :
\series default
 Une fois que le joueur a lancé une partie, un terrain de jeu occupant tout
 l’écran sera présenté au joueur.
 C’est ici que les différentes entités apparaîtront au fur et à mesure.
 Un inventaire (interactif) et des indicateurs (statistiques de partie)
 sont affichés par superposition.
\end_layout

\begin_layout Itemize

\series bold
Echelle :
\series default
 Les coordonnées ainsi que la taille des différents objets graphiques seront
 relatives à la taille de l’écran (la proportion de l’écran occupée par
 l’objet).
 Cela permettra de rendre automatique la mise à l’échelle des éléments graphique
s pour différentes configurations d’écran.
\end_layout

\begin_layout Itemize

\series bold
Bilan :
\series default
 A la fin de la partie, un écran de fin s’affiche présentant le score du
 joueur (calculé sur la base du nombre de semaines où le réseau était efficace
 et de voyageurs transportés).
\end_layout

\begin_layout Itemize

\series bold
Couleurs :
\series default
 L’interface graphique sera le plus épuré possible avec des couleurs simples
 et contrastées et le minimum de couleurs possibles.
 L’interface graphique disposera d’un mode sombre où les gammes de couleurs
 claires sont remplacées par des nuances plus sombres.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Temps :
\series default
 Le temps sera organisé en jours et semaines (jour : ~20 secondes, 1 semaine
 : ~140 secondes).
 Ce système servira à déterminer en partie le score final du joueur.
 Il sera possible de stopper, d'accélérer ou de reprendre le temps.
\end_layout

\begin_layout Itemize

\series bold
Bilan :
\series default
 Un bilan sera aussi proposé au joueur (comprenant des graphiques, cartes
 de fréquentation...) pour que le joueur puisse analyser ses performances.
\end_layout

\begin_layout Itemize

\series bold
\bar under
Son :
\series default
\bar default
 Le jeu comprendra une musique de fond apaisante ainsi que des effets sonores
 pour mettre le joueur dans l’ambiance du jeu.
\end_layout

\begin_layout Itemize

\series bold
Objets :
\series default
 Les objets sont les éléments que le joueur pourra disposer librement sur
 le terrain de jeu.
 Tous les objets seront présents en début de partie en quantité limitée
 et stockés dans un inventaire.
 A chaque semaine passée, le joueur obtiendra des récompenses qu'il pourra
 choisir entre 2 ou 3 objets proposés aléatoirement.
 Les objets seront les suivants : 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Locomotives :
\series default
 Les locomotives sont les véhicules permettant aux voyageurs de se déplacer
 entre les différentes stations.
 Elles seront affectées par le joueur à une ligne en particulier et effectueront
 des allers-retours sur cette dernière.
\end_layout

\begin_layout Itemize

\series bold
Lignes : 
\series default
Les lignes seront les infrastructures permettant aux locomotives de circuler
 de station en station.
 Elles seront dessinées par le joueur et pourront être modifiées au fur
 et à mesure de la partie.
 Les lignes seront représentées à la manière d’un plan de métro, c’est-à-dire
 en utilisant des lignes horizontales et verticales ainsi que des angles
 à 45° pour les virages.
\end_layout

\begin_layout Itemize

\series bold
Wagons :
\series default
 Les wagons sont des véhicules pouvant être ajoutés à une locomotive afin
 d’augmenter le nombre de passagers qu’elle peut transporter en une seule
 fois.
\end_layout

\begin_layout Itemize

\series bold
Ponts :
\series default
 En cas d’implémentation de topologie (ex : cours d’eau) sur la carte, ils
 seront utiles pour les franchissements d’obstacle.
\end_layout

\begin_layout Itemize

\series bold
\bar under
Technicien :
\series default
\bar default
 Si implémentation d’une fonctionnalité de détérioration des lignes, le
 technicien permet de restaurer l'état de la ligne.
\end_layout

\begin_layout Itemize

\series bold
\bar under
Surdimensionnement de la gare :
\series default
\bar default
 Les rames passant par une gare surdimensionnée passeront moins de temps
 à quai.
 Ces gares ont également une plus grande capacité d’accueil des passagers
 (peut accueillir 12 passagers au lieu de 6).
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Entités :
\series default
 Les entités sont les éléments qui seront disposés sur le terrain de jeu
 par le programme.
 Le joueur ne pourra pas interagir de manière directe avec les entités,
 c’est-à-dire qu’elles ne seront pas modifiables par le joueur.
 Les entités seront les suivantes : 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Stations :
\series default
 Les stations sont de différentes formes géométriques et sont générées de
 manière aléatoire.
 Elles apparaîtront à des instants t déterminés par une fonction (linéaire
 puis éventuellement logarithmique/polynomiale).
 Elles seront disposées sur le terrain de jeu de manière homogène, c'est-à-dire
 en évitant les stations superposées ou trop proches et de même type (utilisatio
n d'une carte de fréquentation).
 
\end_layout

\begin_layout Itemize

\series bold
Passagers :
\series default
 Les passagers seront également de différentes formes géométriques (correspondan
t à leur station d'arrivée) à côté des stations à des instants t déterminés
 par une fonction (linéaire puis éventuellement logarithmique/polynomiale).
 Ces passagers disparaissent une fois arrivés à destination.
 Un algorithme de résolution des graphes (pondéré en fonction de l’occupation
 des lignes et du temps de transit entre les stations) sera utilisé afin
 de calculer l’itinéraire des passagers.
\end_layout

\begin_layout Itemize

\series bold
Fleuves :
\series default
 Les différentes cartes comprendront un ou plusieurs fleuves qui feront
 office d’obstacle naturel et devront être contournés par le joueur en utilisant
 les objets qu’il a à sa disposition.
 -Animation : Les entités ainsi que les objets seront animés de manière
 à attirer l’attention du joueur sur les différents éléments (déplacement
 des rames, signalement d’une gare encombrée) affichés.
 Le niveau de détail de ces animations dépendra de l’avancement du projet.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Difficulté :
\series default
 La difficulté du jeu se trouvera dans le fait de devoir fluidifier au maximum
 le trafic et d’adapter le réseau en fonction des nouvelles stations qui
 apparaissent, le flux de passagers ainsi que des différents aléas.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\bar under
Niveaux de difficulté :
\series default
\bar default
 Le joueur aura le choix entre 3 niveaux de difficulté (facile, moyen, difficile
).
\end_layout

\begin_layout Itemize

\series bold
\bar under
Détérioration des lignes :
\series default
\bar default
 Les lignes auront une durée de vie limitée (en fonction du nombre de rames
 les parcourant) et pourront être sous la contrainte d’aléas naturels (feu,
 inondation etc.).
 Le joueur pourra alors les restaurer à l’aide de l’objet “Technicien”.
\end_layout

\begin_layout Itemize

\series bold
Fin de partie :
\series default
 La partie prend fin une fois qu’une station est engorgée (quand plus de
 6 passagers s’y trouvent) pendant un temps qui dépendra de la difficulté
 choisie.
 Un chronomètre apparaitra à côté de la/des stations surchargée(s) pour
 indiquer le temps restant au joueur.
 Si ce temps est dépassé (environ 30 secondes ; varie selon la difficulté)
 alors que la station est encore encombrée, le joueur perd.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\bar under
Enregistrement et chargement de parties :
\series default
\bar default
 Le joueur pourra enregistrer ses parties dans des fichiers de sauvegarde
 ainsi que les charger.
 Cela contribuera également à la démonstration finale du jeu afin de charger
 une partie en cours et de faire la démonstration.
\end_layout

\begin_layout Itemize

\series bold
\bar under
Fonctionnalités cachées :
\series default
\bar default
 Dans ce jeu, cela pourrait être une gare qui n’apparait que dans certaines
 circonstances, une blague accessible à certains joueurs chanceux...
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Subsection
Nommage
\end_layout

\begin_layout Standard
Afin que le code soit structure et facile à comprendre, nous avons adopté
 une convention d'écriture qui suit les règles suivantes :
\end_layout

\begin_layout Itemize
Langage : l'écriture du code en anglais nous semblais assez naturel, car
 cela est plus homogène avec le langage de programation lui-meme (écrit
 en anglais).
 Cependant, afin de faciliter le compréhension du code pour les correcteurs,
 nous avons utilisé du français pour les commentaires.
 Ces dernier par ailleurs suivent une certaines structure.
 Pour un commentaire faisant office de titre, 
\begin_inset Quotes fld
\end_inset

//
\begin_inset Quotes frd
\end_inset

 de 
\begin_inset Quotes fld
\end_inset

-
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// - Section
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// - - Sous-section
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Commentaire standard.
\end_layout

\begin_layout Plain Layout

Procedure Station_Render();
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Constantes : Les constantes sont nommées 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Const Station_Maximum
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Types : Tout types porte d'abord comme identifiant 
\begin_inset Quotes fld
\end_inset

Type_
\begin_inset Quotes frd
\end_inset

 suivit de l'identifiant du type.
 Cet identifiant doit le plus court et le plus explicite possible.
 Par exemple la structure contenant une station s'appelle 
\begin_inset Quotes fld
\end_inset

Type_Station
\begin_inset Quotes frd
\end_inset

.
 Dans le cas d'un type pointeur, il suffit de rajouter 
\begin_inset Quotes fld
\end_inset

_Pointer
\begin_inset Quotes frd
\end_inset

 au nom du type de base.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Type Type_Station = Record
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

End;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Type Type_Station_Pointer = ^Type_Station;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Fonctions et procédures : Les fonctions et procédures portent généralement
 le nom de l'objet sur lequel elles agissent où de l'unité concerné, suivi
 d'un verbe (en général : 
\begin_inset Quotes fld
\end_inset

Get
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Set
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Refresh
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

Render
\begin_inset Quotes frd
\end_inset

 ...) indiquant l'action effectuée et suivi éventuellement plus de précision
 sur l'action.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Procedure rafraichissant les graphismes
\end_layout

\begin_layout Plain Layout

Procedure Graphics_Refresh();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Procedure qui rend graphiquement une station
\end_layout

\begin_layout Plain Layout

Procedure Station_Render();
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Structure générale
\end_layout

\begin_layout Standard
Le projet est structuré en plusieurs fichiers de la manière suivante :
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arbre des dépendances
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Graphiques/Dépendances.png
	width 50page%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Unit_Types :
\series default
 Unité contenant tout les types
\end_layout

\begin_layout Itemize

\series bold
Unit_Constants :
\series default
 Unité contenant toutes les constantes du jeu.
\end_layout

\begin_layout Itemize

\series bold
Unit_Common :
\series default
 Unité contenant toutes les fonctions 
\begin_inset Quotes fld
\end_inset

élémentaires
\begin_inset Quotes frd
\end_inset

 permettants de simplifier le développement dans les autres unités.
\end_layout

\begin_layout Itemize

\series bold
Unit_Mouse :
\series default
 Unité regroupant toutes les fonctions responsable de la prise en charge
 de la souris.
\end_layout

\begin_layout Itemize

\series bold
Unit_Animation :
\series default
 Unité regroupant toutes les fonctions responsable des animations (déplacement
 des trains, ).
\end_layout

\begin_layout Itemize

\series bold
Unit_Graphics :
\series default
 Unité regroupant toutes les fonctions relatives aux graphismes.
\end_layout

\begin_layout Itemize

\series bold
Unit_Logic :
\series default
 Unité regroupant toute la logique du jeu.
 C'est l'unité 
\begin_inset Quotes fld
\end_inset

mère
\begin_inset Quotes frd
\end_inset

 du jeu, celle qui est directement inclu dans le programme principal : 
\begin_inset Quotes fld
\end_inset

INSAtram.pas
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsection
Unité
\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
Ainsi
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Organisation
\end_layout

\begin_layout Subsection
Outils utilisés
\end_layout

\begin_layout Standard
Voici la liste des outils utilisés pour le développement du jeu :
\end_layout

\begin_layout Itemize
Visual Studio Code : Un editeur de code open source et grauit, très extensible
 et personnalisable.
\end_layout

\begin_layout Itemize
Git : Logiciel de gestion de répertoire de code open source et performant.
\end_layout

\begin_layout Itemize
GitHub : Plateforme en ligne d'hébergement de répertoire de code Git.
\end_layout

\begin_layout Itemize
Live Share : Une extension de Visual Studio Code permettant une collaboration
 en direct (à la manière d'un Google Docs).
\end_layout

\begin_layout Itemize
Ptop : Le formateur de code fourni avec le Free Pascal Compiler.
\end_layout

\begin_layout Itemize
Inkscape : Logiciel de dessin vectoriel utilisé pour la création des ressources
 graphiques du jeu.
\end_layout

\begin_layout Subsection
Répartition
\end_layout

\begin_layout Standard
Afin d'avoir une répartition du travail homogène.
 Nous avons adopté une méthode similaire à la méthode 
\begin_inset Quotes fld
\end_inset

Agile
\begin_inset Quotes frd
\end_inset

.
 C'est à dire que nous avons essayé de diviser le cahier des charges en
 
\begin_inset Quotes fld
\end_inset

tâches élémentaires
\begin_inset Quotes frd
\end_inset

 le plus équitablement possible en temps de travail.
 Ces tâches étaient disposés sur un dashboard.
 Puis, chaques personnes vient récupérer une tâche sur un tableau dès que
 la précédente est implémenté, testée et validée par les autres.
 Afin de ne pas avoir à être systématiquement en présentiel pour pouvoir
 travailler ensemble sur le projet.
 Nous avons utilisé des outils tels 
\begin_inset Quotes fld
\end_inset

Git
\begin_inset Quotes frd
\end_inset

 et 
\begin_inset Quotes fld
\end_inset

GitHub
\begin_inset Quotes frd
\end_inset

 pour la gestion du répertoire de code et 
\begin_inset Quotes fld
\end_inset

Live Share
\begin_inset Quotes frd
\end_inset

 afin de collaborer le plus facilement possible.
 C'est pour cela que nous avons utilisé l'éditeur de code Visual Studio
 Code du fait de sa modularité.
 Biensur, en cas de soucis où de problème difficile à résoudre (voir section
 4), nous nous concertions et élaborions une solution ensemble.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Difficultés rencontrés
\end_layout

\begin_layout Subsection
Traçage des lignes
\end_layout

\begin_layout Subsubsection
Géométrie des lignes
\end_layout

\begin_layout Standard
Afin de donner un aspect de 
\begin_inset Quotes fld
\end_inset

plan de métro
\begin_inset Quotes frd
\end_inset

 aux lignes de tram.
 L'affichage des lignes doit se faire uniquement avec des droites horizontales,
 verticales et obliques (45°).
 Ce problème, qui nous semblait assez abstrait et abitraire au premiers
 abords, étaient finalement relativement simple à résoudre avec l'étude
 d'un des cas possible.
 Voici notre démarche :
\end_layout

\begin_layout Itemize
Deux stations, représentées par les points 
\begin_inset Formula $S_{N}=\left(S_{N,x},S_{N,y}\right)$
\end_inset

 et 
\begin_inset Formula $S_{N+1}=\left(S_{N+1,x},S_{N+1,y}\right)$
\end_inset

 (coordonnées centrés des stations), sont séparé par les distances 
\begin_inset Formula $\Delta_{x}=S_{N+1,x}-S_{N,x}$
\end_inset

 et 
\begin_inset Formula $\Delta_{y}=S_{N+1,y}-S_{N,y}$
\end_inset

.
 Les indices 
\begin_inset Formula $N$
\end_inset

 et 
\begin_inset Formula $N+1$
\end_inset

 font référence aux position relatives des stations dans les tableaux de
 pointeurs de station stoqués dans les objets de type 
\begin_inset Quotes fld
\end_inset

Type_Line
\begin_inset Quotes frd
\end_inset

.
 Les deux stations forment un angle 
\begin_inset Formula $\alpha=arctan\left(\frac{\Delta_{y}}{\Delta_{x}}\right)$
\end_inset

 par rapport à l'axe des abscisses.
 Soit 
\begin_inset Formula $s_{1}$
\end_inset

 le segment passant par 
\begin_inset Formula $S_{N}$
\end_inset

 et 
\begin_inset Formula $s_{2}$
\end_inset

 le segment passant par 
\begin_inset Formula $S_{N+1}$
\end_inset

.
 Dans le cas où 
\begin_inset Formula $-135°<a<-45°$
\end_inset

, pour relier les deux stations avec un segment vertical/horizontal et un
 obliques, il existe plusieurs possibilités : 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $s_{1}$
\end_inset

 oblique et 
\begin_inset Formula $s_{2}$
\end_inset

 vertical
\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{1}$
\end_inset

 vertical et 
\begin_inset Formula $s_{2}$
\end_inset

 oblique
\end_layout

\end_deeper
\begin_layout Itemize
Il est important de noter que nous avons choisi comme convention que 
\begin_inset Formula $s_{1}$
\end_inset

 serait toujours vertical où horizontal et 
\begin_inset Formula $s_{2}$
\end_inset

 oblique.
 
\end_layout

\begin_layout Itemize
Ainsi, le sens et la direction de 
\begin_inset Formula $s_{1}$
\end_inset

 et de 
\begin_inset Formula $s_{2}$
\end_inset

 sera alors déterminé avec 
\begin_inset Formula $\alpha$
\end_inset

.
 Dans notre exemple, 
\begin_inset Formula $s_{1}$
\end_inset

 est horizontal et donc part à gauche de 
\begin_inset Formula $S_{N}$
\end_inset

.
 Alors que 
\begin_inset Formula $s_{2}$
\end_inset


\end_layout

\begin_layout Itemize
Afin de dessiner ces segments, la SDL à besoin des coordonnées de départ
 et d'arrivé pour tracer un segment (donc de 
\begin_inset Formula $S_{N}$
\end_inset

 et 
\begin_inset Formula $I$
\end_inset

 pour 
\begin_inset Formula $s_{1}$
\end_inset

 et de 
\begin_inset Formula $I$
\end_inset

 et 
\begin_inset Formula $S_{N+1}$
\end_inset

 pour 
\begin_inset Formula $s_{2}$
\end_inset

).
 Notre objectif est alors de déterminer les coordonnées du point 
\begin_inset Formula $I$
\end_inset

 tel que 
\begin_inset Formula $I=\left(I_{x},I_{y}\right)$
\end_inset

 en fonction des coordonnées des stations 
\begin_inset Formula $S_{N}$
\end_inset

 et 
\begin_inset Formula $S_{N+1}$
\end_inset

.
 Par la suite, nous appelleront 
\begin_inset Formula $I$
\end_inset

, la position intermédiaire.
 
\end_layout

\begin_layout Itemize
Tout d'abord, 
\begin_inset Formula $s_{1}$
\end_inset

 étant vertical, on a 
\begin_inset Formula $I_{x}=A_{x}$
\end_inset

.
 On place maintenant le point 
\begin_inset Formula $E$
\end_inset

, l'intersection de la droite 
\begin_inset Formula $(IB)$
\end_inset

 et de la droite horizontale passant par 
\begin_inset Formula $B$
\end_inset

.
 On a alors 
\begin_inset Formula $E=\left(A_{x},B_{y}\right)$
\end_inset

.
 Or, 
\begin_inset Formula $s_{2}$
\end_inset

 possède un angle de 
\begin_inset Formula $\widehat{EIB}=45°$
\end_inset

 par rapport à l'axe des ordonnées (par définition).
 De plus, l'angle 
\begin_inset Formula $\widehat{IEB}=90°$
\end_inset

 il s'agit de l'intersection droite verticale et horizontale (donc perpendiculai
res).
 Le triangle 
\begin_inset Formula $IBE$
\end_inset

 étant rectangle en 
\begin_inset Formula $E$
\end_inset

 et possédant un angles à 
\begin_inset Formula $45°$
\end_inset

, il est donc rectangle isocèle en 
\begin_inset Formula $E$
\end_inset

.
 Cela permet d'en déduire que 
\begin_inset Formula $\overline{IE}=-\overline{EB}$
\end_inset

, or 
\begin_inset Formula $E=\left(A_{x},B_{y}\right)$
\end_inset

 on a donc :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overline{IE}=-\overline{EB}\Rightarrow E_{y}-I_{y}=-\left(B_{x}-E_{x}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow I_{y}=-B_{x}+E_{x}-E_{y}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow I_{y}=-B_{x}+A_{x}-B_{y}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow I_{y}=B_{y}-\Delta_{x}
\]

\end_inset


\end_layout

\begin_layout Standard
On a donc 
\begin_inset Formula $I=\left(A_{x},B_{y}-\Delta_{x}\right)$
\end_inset

.
 Il suffit
\end_layout

\begin_layout Standard
Pour les autres configuration de 
\begin_inset Formula $\alpha$
\end_inset

, le même raisonnement peut être appliqué.
 Il faut cependant faire attention aux signes des différentes composantes
 qui change Ce même raisonnement peut s'appliquer aisément à différents
 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Standard
Ainsi, pour les autres cas
\end_layout

\begin_layout Itemize
.
 On remarque assez vite que le triangle formé en bas.
 
\end_layout

\begin_layout Standard
peut être simplifié par l'utilisation de ce qu'on à appelé un point intermédiair
e.
 En effets, sur un plan de métro, on constate que les lignes.
\end_layout

\begin_layout Standard
Un autre aspect à été celui de la cohabitation de plusieurs lignes
\end_layout

\begin_layout Subsubsection
Épaisseur des lignes
\end_layout

\begin_layout Standard
Plus tard dans le développement, nous nous somme rendu compte que le traçage
 de lignes sans épaisseur (fonction 
\begin_inset Quotes fld
\end_inset

aadrawlineRGBA
\begin_inset Quotes frd
\end_inset

 de l'unité SDL GFX) rendait le repérage des lignes peu distinguables du
 reste.
 Or la SDL ne supporte pas nativement le traçage des lignes d'une épaisseur
 donnée.
 Nous nous sommes penchés sur l'unité 
\begin_inset Quotes fld
\end_inset

SDL GFX
\begin_inset Quotes frd
\end_inset

 qui possède une fonction 
\begin_inset Quotes fld
\end_inset

thickLineRGBA
\begin_inset Quotes frd
\end_inset

 permetant de dessiner des lignes avec une épaisseur.
 Malheureusement, les liens entre l'implémentation C de la SDL et le Free
 Pascal Compiler étant incomplets, la fonction n'était pas accessible en
 Free Pascal.
 Cet soucis n'ayant pas été anticipé, nous avons donc dû réfléchir à une
 solution simple pour contourner le soucis.
 Ainsi, à partir de la fonction 
\begin_inset Quotes fld
\end_inset

aadrawlineRGBA
\begin_inset Quotes frd
\end_inset

 et de l'angle de la ligne.
 Nous avons dessiné des lignes superposé les unes par rapport aux autres.
 Permetant ainsi de créer une ligne épaisse.
 Dans le cas de ligne verticales et horizontales, il est assez aisé de dessiner
 une ligne épaisse en incrémentant et décrémentant 
\begin_inset Formula $x$
\end_inset

 où 
\begin_inset Formula $y$
\end_inset

 autour du centre de la ligne :
\end_layout

\begin_layout Standard
Cependant, dans le cas de lignes obliques, ce raisonnement n'est pas valide.
 
\end_layout

\begin_layout Subsection
Résolution des itinéraires des passagers
\end_layout

\begin_layout Standard
Toute la difficulté du jeu reposant sur la performance du réseau créé, il
 était impératif pour nous que les passagers fassent preuve d'intelligence
 dans leur choix d'itinéraire.
 Dans le cas contraire, il n'y aurait aucune incitation à construire un
 plan de réseau efficace.
 La recherche du plus court chemin est un problème informatique classique,
 et de nombreux algorithmes existent pour sa résolution.
 Nous ne sommes pas mathématiciens ni chercheurs, alors nous avons décidé
 d'en adopter un assez connu, l'algorithme de Dijkstra.
 Cet algorithme est supposé être de complexité 
\begin_inset Formula $\text{O}\left(\left(n+a\right)\text{log}\left(n\right)\right)$
\end_inset

.
 Cependant, étant donné que nous avons fait l'implémentation de cet algorithme
 assez théorique de nous même, en s'inspirant seulement de son fonctionnement
 quand exécuté 
\begin_inset Quotes fld
\end_inset

à la main
\begin_inset Quotes frd
\end_inset

, il serait très peu surprenant d'apprendre que sa complexité s'en soit
 trouvée agrandie.
 L'écriture des fonctions et procédures liées à la résolution d'itinéraire
 en elle même n'a pas présenté de difficulté majeure, l'algorithme n'étant
 pas excessivement compliqué à appréhender.
 En revanche, toutes les subtilités d'allocation de mémoire, les tableaux
 sur plusieurs dimensions, la rigueur dans le choix des indexes, ou bien
 la fragmentation des différentes tâches prérequises à l'exécution de Dijkstra
 dans de nombreuses fonctions, eux, ont été source de bugs ayant nécessité
 de longues heures de débogage.
 
\end_layout

\begin_layout Subsection
Animation réaliste des trains
\end_layout

\begin_layout Standard
Afin que le mouvement des trains soit réaliste, au lieu d'une vitesse constante,
 nous avons opté pour une vitesse variable dépendant du temps.
 Le but étant de mimer le déplacement d'un véhicule réel.
\end_layout

\begin_layout Standard
Ainsi, pour le déplacement du véhicule, on peu définir trois périodes :
\end_layout

\begin_layout Itemize
L'accélération : le temps 
\begin_inset Formula $t_{a}$
\end_inset

 que le train atteigne sa vitesse maximale 
\begin_inset Formula $v_{m}$
\end_inset

.
\end_layout

\begin_layout Itemize
Croisière : le temps où le train est à sa vitesse maximale : 
\begin_inset Formula $v_{m}$
\end_inset

.
\end_layout

\begin_layout Itemize
Décélération : le temps 
\begin_inset Formula $t_{d}$
\end_inset

 que le train train met pour atteindre une vitesse nulle.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Pour des questions de simplicité, nous considérons que le train prend autant
 de temps à accélérer, qu'a décélérer (
\begin_inset Formula $t_{a}=t_{d}$
\end_inset

).
 Nous avons alors utilisé 
\begin_inset Quotes fld
\end_inset

Geogebra
\begin_inset Quotes frd
\end_inset

 et tâtonné un peu afin de trouver une fonction qui décrit au mieux la vitesse
 d'un véhicule 
\begin_inset Quotes fld
\end_inset

réel
\begin_inset Quotes frd
\end_inset

 lors de son accélération (
\begin_inset Formula $a\left(x\right)=\frac{\cos\left(x\right)+1}{2}$
\end_inset

) et de sa décélération (
\begin_inset Formula $d\left(x\right)=\frac{-\cos\left(x\right)+1}{2}$
\end_inset

).
 
\end_layout

\begin_layout Standard
Avec ces 3 périodes et fonctions, on peut alors définir la vitesse comme
 une fonction par morceaux dépendant du temps :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v(t)\begin{cases}
v_{1}\left(t\right)=v_{m}\cdot\frac{-\cos\left(k\cdot t\right)+1}{2} & \text{si }0\leqslant t\leqslant t_{a}\\
v_{2}\left(t\right)=v_{m} & \text{si }t_{a}<t<t_{f}-t_{a}\\
v_{3}\left(t\right)=v_{m}\cdot\frac{\cos\left(k\cdot t\right)+1}{2} & \text{si }t_{f}-t_{a}\leqslant t\leqslant t_{f}
\end{cases},\forall t\in\left[0,t_{f}\right],\forall k\in
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $k$
\end_inset

 étant une constante permetant de module le cosinus en fonction de 
\begin_inset Formula $t_{a}$
\end_inset

 et 
\begin_inset Formula $v_{max}$
\end_inset

, en effet :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v\left(t_{a}\right)=v_{m}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow v_{m}\cdot\frac{-\cos\left(k\cdot t_{a}\right)+1}{2}=v_{m}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow\cos\left(k\cdot t_{a}\right)=-1
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Rightarrow k=\frac{\arccos\left(-1\right)}{t_{a}}=\frac{\pi}{t_{a}}
\]

\end_inset


\end_layout

\begin_layout Standard
Une fois les équations horraires de la vitesse obtenus, nous pouvons en
 déduire la distance du train parcouru depuis la dernière station.
 En effet, d'après les cours de mécanique du point (P2), nous savons que
 la vitesse est la dérivée de la distance parcourue : 
\begin_inset Formula $v\left(t\right)=\frac{d}{dt}d\left(t\right)$
\end_inset

, on a donc :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d\left(t\right)=\int v\left(t\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $v\left(t\right)$
\end_inset

 étant définie par morceaux, 
\begin_inset Formula $d$
\end_inset


\begin_inset Formula $\left(t\right)$
\end_inset

 est également définie par morceaux :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d\left(t\right)=\begin{cases}
d_{1}\left(t\right)=\int_{0}^{t}v_{1}\left(t\right) & \text{si }0\leqslant t\leqslant t_{a}\\
d_{2}\left(t\right)=\int_{0}^{t_{a}}v_{1}\left(t\right)+\int_{t_{a}}^{t}v_{2}\left(t\right) & \text{si }t_{a}<t<t_{f}-t_{a}\\
\int v\left(t\right)=\int_{0}^{t_{a}}v_{1}\left(t\right)+\int_{t_{a}}^{t_{f}-t_{a}}v_{2}\left(t\right)+\int_{0}^{t-\left(t_{f}-t_{a}\right)}v_{3}\left(t\right) & \text{si }t_{f}-t_{a}\leqslant t\leqslant t_{f}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula 
\[
\Rightarrow d\left(t\right)=\begin{cases}
d_{1}\left(t\right)=\int_{0}^{t_{a}}\left(v_{m}\cdot\frac{-\cos\left(k\cdot t\right)+1}{2}\right)dt & \text{si }0\leqslant t\leqslant t_{a}\\
d_{2}\left(t\right)=d_{1}\left(t_{a}\right)+\int_{t_{a}}^{t}\left(v_{m}\right)dt & \text{si }t_{a}<t<t_{f}-t_{a}\\
d_{3}\left(t\right)=d_{1}\left(t\right)+d_{2}\left(t_{f}-t_{a}\right)-d_{2}\left(t_{a}\right)+\int_{0}^{t-\left(t_{f}-t_{a}\right)}\left(v_{m}\cdot\frac{\cos\left(k\cdot t\right)+1}{2}\right)dt & \text{si }t_{f}-t_{a}\leqslant t\leqslant t_{f}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula 
\[
\Rightarrow d\left(t\right)=\begin{cases}
d_{1}\left(t\right)=\left[v_{m}\cdot\left(\frac{-\sin\left(k\cdot t\right)+kt}{k*2}\right)\right]_{0}^{t_{a}} & \text{si }0\leqslant t\leqslant t_{a}\\
d_{2}\left(t\right)=d_{1}\left(t_{a}\right)+\left[v_{m}\cdot t\right]_{t_{a}}^{t} & \text{si }t_{a}<t<t_{f}-t_{a}\\
d_{3}\left(t\right)=d_{1}\left(t\right)+d_{2}\left(t_{f}-t_{a}\right)-d_{2}\left(t_{a}\right)+\left[\frac{1}{2}\left(\frac{\sin\left(k\cdot t\right)}{k}+t\right)\right]_{0}^{t-\left(t_{f}-t_{a}\right)} & \text{si }t_{f}-t_{a}\leqslant t\leqslant t_{f}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula 
\[
\Rightarrow d\left(t\right)=\begin{cases}
d_{1}\left(t\right)=v_{m}\cdot\left(\frac{-\sin\left(k\cdot t\right)+kt}{k*2}\right) & \text{si }0\leqslant t\leqslant t_{a}\\
d_{2}\left(t\right)=d_{1}\left(t_{a}\right)+v_{m}\times\left(t-t_{a}\right) & \text{si }t_{a}<t<t_{f}-t_{a}\\
d_{3}\left(t\right)=d_{1}\left(t\right)+d_{2}\left(t_{f}-t_{a}\right)-d_{2}\left(t_{a}\right)+\left[\frac{1}{2}\left(\frac{\sin\left(k\cdot t\right)}{k}+t\right)\right]_{0}^{t-\left(t_{f}-t_{a}\right)} & \text{si }t_{f}-t_{a}\leqslant t\leqslant t_{f}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Nous avons maintenant la position en fonction du temps, ce qui est suffisant
 pour réaliser l'implémentation.
\end_layout

\begin_layout Subsection
Optimisations
\end_layout

\begin_layout Standard
Au fur et à mesure que le projet avançait et que les ressources graphiques
 se multipliaient.
 Nous nous somme heurté à un problème de performance qui affectait la fluidité
 du jeu.
 Ainsi, après quelques recherches, nous avons procédé à quelques optimisations
 relativement simples :
\end_layout

\begin_layout Itemize
Tout d'abord, lorsque la SDL créer des surface à partir d'images importés,
 cette dernière ont une format de pixel (profondeur de couleur, masques,
 cannal alpha ...) qui n'est pas forcément le même que celui de l'affichage.
 Or, lors du rendu (fonction 
\begin_inset Quotes fld
\end_inset

SDL_BlitSurface
\begin_inset Quotes frd
\end_inset

), la SDL doit effectuer une convertion à la volée pour rendre la surface
 sur l'écran.
 Cette conversion nécéssite beaucoup de temps de calculs.
 Cependant, il est possible de s'affranchir de cette conversion à la volée
 en en effectuant la convertion dès l'importation de la ressource graphique.
 Cette convertion est alors effectué, avec la fonction SDL_VideoFormat qui
 prend pour paramètre la surface à convertir, et renvoi une nouvelle surface,
 qui est la conversion de la première.
 Enfin, pour que cette convertion soit réellement effective, il faut également
 modifier les clée ??? .
 Dans le cas d'utilisation surface avec un canal Alpha (RGBA), il plutot
 utiliser la fonction SDL_Format afin qu
\end_layout

\begin_layout Itemize
Ensuite, il est possible d'utiliser l'accélération graphique matériel pour
 certains calculs graphiques (notamment pour l'anti-crénelage, les calculs
 géométrique pour le dessin des formes, la copie de mémoire massive etc.).
 Il faut remplaceavec l'option SDL_SWSURFACE par SDL_HWSURFACE dans la fonction
 qui instancie la fenêtre (SDL_SetVideoMode) pour activer cette fonctionnalité.
 Cependant, cette optimisation est conditionnée au support d'interfaces
 de programmation (API) graphiques spécifiques au matériel et aux pilotes
 d'une machine (OpenGL).
 Ainsi, sur des configurations plus exotiques ou anciennes, il se peut que
 des problèmes de compatibilités empêchent le lancement du jeu.
\end_layout

\begin_layout Subsection
Interface graphiques
\end_layout

\begin_layout Standard
Une interface graphique est nécéssaire pour que l'utilisateur puisse interragir
 avec notre jeu.
 Or la SDL est une librairie très rudimentaire en terme de fonctionnalité.
 Cependant, la création d'une interface graphique pour .
 Nous avons donc créer une petite abstraction pour les différents éléments
 de l'interface pour permetre.
 Cette abstraction est constitués de :
\end_layout

\begin_layout Itemize
Type : 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
j
\end_layout

\end_body
\end_document
